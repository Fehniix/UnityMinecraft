using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Extensions;

/// <summary>
/// A chunk is a cubic structure of fixed side that contains individual blocks.
/// Chunks are generated by the TerrainGenerator.
/// </summary>
[RequireComponent(typeof(TextureStitcher))]
public class Chunk
{	
	/// <summary>
	/// Individual blockNames contained within the chunk.
	/// </summary>
    public BaseBlock[,,] blocks;

	/// <summary>
	/// (x,z) size of the chunk.
	/// </summary>
	[SerializeField] 
	private int chunkSize = 16;

	/// <summary>
	/// y-size of the chunk.
	/// </summary>
	[SerializeField]
	private int chunkHeight = 256;

	/// <summary>
	/// Private reference to the game object first created by BuildMesh().
	/// </summary>
	private GameObject chunkGameObject;

	/// <summary>
	/// x-position of the chunk.
	/// </summary>
	public int x;

	/// <summary>
	/// z-position of the chunk.
	/// </summary>
	public int z;

	/// <summary>
	/// Used to build a quad's triangles.
	/// </summary>
	private int[] identityQuad = new int[] {
		0, 1, 3,
		1, 2, 3
	};

	public Chunk()
	{
		this.blocks = new BaseBlock[this.chunkSize, this.chunkHeight, this.chunkSize];
	}

	public void BuildMesh()
	{
		if (this.chunkGameObject == null)
		{
			// Instantiate the GameObject (and implictly add it to the scene).
			this.chunkGameObject = new GameObject("Chunk");

			// Get the stitched texture.
			Texture2D texture = TextureStitcher.instance.StitchedTexture;

			// Add mesh filter and renderer.
			this.chunkGameObject.AddComponent<MeshFilter>();
			this.chunkGameObject.AddComponent<MeshRenderer>();
			this.chunkGameObject.AddComponent<MeshCollider>();
			this.chunkGameObject.AddComponent<ChunkObject>();

			this.chunkGameObject.GetComponent<MeshRenderer>().material.mainTexture = texture;
			this.chunkGameObject.transform.position = new Vector3(this.x * this.chunkSize, 0, this.z * this.chunkSize);
		}

		Mesh mesh = new Mesh();

		List<Vector3> vertices	= new List<Vector3>();
		List<Vector2> uvs		= new List<Vector2>();
		List<int> triangles 	= new List<int>();

		// Keeps track of the number of faces already built.
		int builtFaces = 0;

		for (int i = 0; i < this.chunkSize; i++)
			for (int j = 0; j < this.chunkHeight; j++)
				for (int k = 0; k < this.chunkSize; k++)
				{
					// Determine block adjacency with air. For each adjacent block face, render the face.

					// If the block itself is air, don't render anything
					if (this.blocks[i,j,k] == null || this.blocks[i,j,k].blockName == "air")
						continue;

					// Top face adjacency
					if (j >= 0 && j <= this.chunkHeight - 1)
						if (j == this.chunkHeight - 1 || this.blocks[i, j + 1, k].blockName == "air")
							// Always render the top most face, OR if the top-adjacent block is "air".
							this.AddFace(i, j, k, builtFaces++, "top", CubeMeshFaces.top, vertices, uvs, triangles);

					// Bottom face adjacency
					if (j >= 0 && j < this.chunkHeight)
						if (j == 0 || this.blocks[i, j - 1, k].blockName == "air")
							this.AddFace(i, j, k, builtFaces++, "bottom", CubeMeshFaces.bottom, vertices, uvs, triangles);
					
					// West face adjacency
					if (i >= 0 && i < this.chunkSize)
						if (i == 0 || this.blocks[i - 1, j, k].blockName == "air")
							this.AddFace(i, j, k, builtFaces++, "west", CubeMeshFaces.west, vertices, uvs, triangles);

					// East face adjacency
					if (i >= 0 && i <= this.chunkSize)
						if (i == this.chunkSize - 1 || this.blocks[i + 1, j, k].blockName == "air")
							this.AddFace(i, j, k, builtFaces++, "east", CubeMeshFaces.east, vertices, uvs, triangles);

					// Front face adjacency
					if (k >= 0 && k < this.chunkSize)
						if (k == 0 || this.blocks[i, j, k - 1].blockName == "air")
							this.AddFace(i, j, k, builtFaces++, "front", CubeMeshFaces.front, vertices, uvs, triangles);

					// Back face adjacency
					if (k >= 0 && k <= this.chunkSize)
						if (k == this.chunkSize - 1 || this.blocks[i, j, k + 1].blockName == "air")
							this.AddFace(i, j, k, builtFaces++, "back", CubeMeshFaces.back, vertices, uvs, triangles);
				}

		mesh.vertices 	= vertices.ToArray();
		mesh.uv 		= uvs.ToArray();
		mesh.triangles 	= triangles.ToArray();

		mesh.RecalculateNormals();

		this.chunkGameObject.GetComponent<MeshFilter>().mesh = mesh;
		this.chunkGameObject.GetComponent<MeshCollider>().sharedMesh = mesh;
		this.chunkGameObject.GetComponent<MeshCollider>().material = CachedResources.Load<PhysicMaterial>("PhysicsMaterials/FrictionLess");
	}

	/// <summary>
	/// Given the block's (i,j,k) vector, the number of built faces, face to build, vertices, uvs and triangles references,
	/// this appends a new face mesh's data on the vertices, uvs and triangles references.
	/// </summary>
	void AddFace(int i, int j, int k, int builtFaces, string faceName, Vector3[] face, List<Vector3> vertices, List<Vector2> uvs, List<int> triangles)
	{
		string textureName = this.blocks[i,j,k].blockName;

		if (this.blocks[i,j,k].textureName != "default")
			textureName = this.blocks[i,j,k].textureName;

		if (this.blocks[i,j,k].hasSidedTextures)
		{
			if (TextureStitcher.instance.TextureUVs.ContainsKey(System.String.Format("{0}_{1}", textureName, faceName)))
				textureName = System.String.Format("{0}_{1}", textureName, faceName);
			else
				textureName = System.String.Format("{0}_{1}", textureName, "side");	
		}

		vertices.AddRange(face.Add((i,j,k)));
		uvs.AddRange(TextureStitcher.instance.TextureUVs[textureName].ToArray());
		triangles.AddRange(this.identityQuad.Add(builtFaces * 4));
	}

	public void Destroy()
	{
		GameObject.Destroy(this.chunkGameObject);
	}

	/// <summary>
	/// Recalculates the chunk mesh's normals.
	/// </summary>
	public void RecalculateNormals()
	{
		this.chunkGameObject.GetComponent<MeshFilter>().mesh.RecalculateNormals();
	}
}
