using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Extensions;

/// <summary>
/// A chunk is a cubic structure of fixed side that contains individual blocks.
/// Chunks are generated by the TerrainGenerator.
/// </summary>
[RequireComponent(typeof(TextureStitcher))]
public class Chunk
{	
	// The blocks contained within the current chunk.
    public string[,,] blocks;

	[SerializeField] 
	private int chunkSize = 16;

	[SerializeField]
	private int chunkHeight = 256;

	/// <summary>
	/// x-position of the chunk.
	/// </summary>
	public int x;

	/// <summary>
	/// z-position of the chunk.
	/// </summary>
	public int z;

	/// <summary>
	/// Used to build a quad's triangles.
	/// </summary>
	private int[] identityQuad = new int[] {
		0, 1, 3,
		1, 2, 3
	};

	public Chunk()
	{
		this.blocks = new string[this.chunkSize, this.chunkHeight, this.chunkSize];

		for (int i = 0; i < this.chunkSize; i++)
			for (int j = 0; j < this.chunkHeight; j++)
				for (int k = 0; k < this.chunkSize; k++)
					this.blocks[i,j,k] = "air";
	}

	public void BuildMesh()
	{
		// Instantiate the GameObject (and implictly add it to the scene).
		GameObject chunk = new GameObject("Chunk");

		// Get the stitched texture.
		Texture2D texture = TextureStitcher.instance.StitchedTexture;

		// Add mesh filter and renderer.
		chunk.AddComponent<MeshFilter>();
		chunk.AddComponent<MeshRenderer>();
		chunk.AddComponent<MeshCollider>();

		Mesh mesh = new Mesh();

		List<Vector3> vertices	= new List<Vector3>();
		List<Vector2> uvs		= new List<Vector2>();
		List<int> triangles 	= new List<int>();

		// Keeps track of the number of faces already built.
		int builtFaces = 0;

		for (int i = 0; i < this.chunkSize; i++)
			for (int j = 0; j < this.chunkHeight; j++)
				for (int k = 0; k < this.chunkSize; k++)
				{
					// Determine block adjacency with air. For each adjacent block face, render the face.

					// If the block itself is air, don't render anything
					if (this.blocks[i,j,k] == "air")
						continue;

					// Top face adjacency
					if (j >= 0 && j <= this.chunkHeight - 1)
						if (j == this.chunkHeight - 1 || this.blocks[i, j + 1, k] == "air")
							// Always render the top most face, OR if the top-adjacent block is "air".
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.top, vertices, uvs, triangles);

					// Bottom face adjacency
					if (j >= 0 && j < this.chunkHeight)
						if (j == 0 || this.blocks[i, j - 1, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.bottom, vertices, uvs, triangles);
					
					// West face adjacency
					if (i >= 0 && i < this.chunkSize)
						if (i == 0 || this.blocks[i - 1, j, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.west, vertices, uvs, triangles);

					// East face adjacency
					if (i >= 0 && i <= this.chunkSize)
						if (i == this.chunkSize - 1 || this.blocks[i + 1, j, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.east, vertices, uvs, triangles);

					// Front face adjacency
					if (k >= 0 && k < this.chunkSize)
						if (k == 0 || this.blocks[i, j, k - 1] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.front, vertices, uvs, triangles);

					// Back face adjacency
					if (k >= 0 && k <= this.chunkSize)
						if (k == this.chunkSize - 1 || this.blocks[i, j, k + 1] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.back, vertices, uvs, triangles);
				}

		mesh.vertices 	= vertices.ToArray();
		mesh.uv 		= uvs.ToArray();
		mesh.triangles 	= triangles.ToArray();

		mesh.RecalculateNormals();

		chunk.GetComponent<MeshFilter>().mesh = mesh;
		chunk.GetComponent<MeshCollider>().sharedMesh = mesh;
		chunk.transform.position = new Vector3(this.x, 0, this.z);

		chunk.GetComponent<MeshRenderer>().material.mainTexture = texture;
	}

	/// <summary>
	/// Given the block's (i,j,k) vector, the number of built faces, face to build, vertices, uvs and triangles references,
	/// this appends a new face mesh's data on the vertices, uvs and triangles references.
	/// </summary>
	void AddFace(int i, int j, int k, int builtFaces, Vector3[] face, List<Vector3> vertices, List<Vector2> uvs, List<int> triangles)
	{
		vertices.AddRange(face.Add((i,j,k)));
		uvs.AddRange(TextureStitcher.instance.TextureUVs[blocks[i,j,k]].ToArray());
		triangles.AddRange(this.identityQuad.Add(builtFaces * 4));
	}
}
