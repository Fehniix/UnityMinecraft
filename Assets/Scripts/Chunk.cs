using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Extensions;

/// <summary>
/// A chunk is a cubic structure of fixed side that contains individual blocks.
/// Chunks are generated by the TerrainGenerator.
/// </summary>
public class Chunk
{	
	// The blocks contained within the current chunk.
    public string[,,] blocks;

	[SerializeField] 
	private int chunkSize = 16;

	[SerializeField]
	private int chunkHeight = 256;

	private int _x;
	private int _y;

	/// <summary>
	/// The x-position in the world's 2D plane of the chunk.
	/// </summary>
	public int x { get; }

	/// <summary>
	/// The y-position in the world's 2D plane of the chunk.
	/// </summary>
	public int y { get; }

	/// <summary>
	/// Used to build a quad's triangles.
	/// </summary>
	private int[] identityQuad = new int[] {
		0, 1, 3,
		1, 2, 3
	};

	public Chunk()
	{
		this.blocks = new string[this.chunkSize, this.chunkHeight, this.chunkSize];

		for (int i = 0; i < this.chunkSize; i++)
			for (int j = 0; j < this.chunkHeight; j++)
				for (int k = 0; k < this.chunkSize; k++)
					this.blocks[i,j,k] = "air";
	}

	public void BuildMesh()
	{
		// Instantiate the GameObject (and implictly add it to the scene).
		GameObject chunk = new GameObject("Chunk");

		// Get the stitched texture.
		Texture2D texture = TextureStitcher.instance.StitchedTexture;

		// Add mesh filter and renderer.
		chunk.AddComponent<MeshFilter>();
		chunk.AddComponent<MeshRenderer>();

		Mesh mesh = new Mesh();

		List<Vector3> vertices	= new List<Vector3>();
		List<Vector2> uvs		= new List<Vector2>();
		List<int> triangles 	= new List<int>();

		// Keeps track of the number of faces already built.
		int builtFaces = 0;

		for (int i = 0; i < this.chunkSize; i++)
			for (int j = 0; j < this.chunkHeight; j++)
				for (int k = 0; k < this.chunkSize; k++)
				{
					// Determine block adjacency with air. For each adjacent block face, render the face.

					// If the block itself is air, don't render anything
					if (this.blocks[i,j,k] == "air")
						continue;

					// Top face adjacency
					if (j >= 0 && j <= this.chunkHeight - 1)
						if (j == this.chunkHeight - 1)
							// Always render the top most face.
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.top, vertices, uvs, triangles);
						else if (this.blocks[i, j + 1, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.top, vertices, uvs, triangles);

					// Bottom face adjacency
					if (j >= 0 && j < this.chunkHeight)
						if (j == 0)
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.bottom, vertices, uvs, triangles);
						else if (this.blocks[i, j - 1, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.bottom, vertices, uvs, triangles);
					
					// West face adjacency
					if (i >= 0 && i < this.chunkSize)
						if (i == 0)
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.west, vertices, uvs, triangles);
						else if (this.blocks[i - 1, j, k] == "air")
							this.AddFace(i, j, k, builtFaces++, CubeMeshFaces.west, vertices, uvs, triangles);
				}

		// vertices.AddRange(CubeMeshFaces.front);
		// vertices.AddRange(CubeMeshFaces.top);
		// vertices.AddRange(CubeMeshFaces.west);
		// vertices.AddRange(CubeMeshFaces.east);

		// uvs.AddRange(TextureStitcher.instance.TextureUVs["dirt"].ToArray());
		// uvs.AddRange(TextureStitcher.instance.TextureUVs["dirt"].ToArray());
		// uvs.AddRange(TextureStitcher.instance.TextureUVs["dirt"].ToArray());
		// uvs.AddRange(TextureStitcher.instance.TextureUVs["dirt"].ToArray());

		// triangles.AddRange(identityQuad);
		// triangles.AddRange(identityQuad.Add(4));
		// triangles.AddRange(identityQuad.Add(8));
		// triangles.AddRange(identityQuad.Add(12));

		mesh.vertices 	= vertices.ToArray();
		mesh.uv 		= uvs.ToArray();
		mesh.triangles 	= triangles.ToArray();

		mesh.RecalculateNormals();

		chunk.GetComponent<MeshFilter>().mesh = mesh;
		chunk.transform.position = new Vector3(10,0,3);

		chunk.GetComponent<MeshRenderer>().material.mainTexture = texture;
	}

	/// <summary>
	/// Given the block's (i,j,k) vector, the number of built faces, face to build, vertices, uvs and triangles references,
	/// this appends a new face mesh's data on the vertices, uvs and triangles references.
	/// </summary>
	void AddFace(int i, int j, int k, int builtFaces, Vector3[] face, List<Vector3> vertices, List<Vector2> uvs, List<int> triangles)
	{
		vertices.AddRange(face.Add((i,j,k)));
		uvs.AddRange(TextureStitcher.instance.TextureUVs[blocks[i,j,k]].ToArray());
		triangles.AddRange(this.identityQuad.Add(builtFaces * 4));
	}
}
